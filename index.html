<!doctype html>
<html lang="en">
<head>
	<title>Castelloscopi</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel=stylesheet href="css/base.css"/>
</head>
<body>

<script src="js/three.min.js"></script>
<script src="js/Detector.js"></script>
<script src="js/libs/stats.min.js"></script>
<script src="js/controls/OrbitControls.js"></script>

<!-- jQuery code to display an information button and box when clicked. -->
<script src="js/jquery-1.9.1.js"></script>
<script src="js/jquery-ui.js"></script>
<link rel=stylesheet href="css/jquery-ui.css" />
<script src="js/video.js"></script>
<div id="videoBox"></div>
<!-- ------------------------------------------------------------ -->

<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>


if ( ! Detector.webgl ) {
	alert("necessites un navegador que suporti webGL");
}

// standard global variables
var container, scene, camera, light, renderer, cameraControls, stats;
var clock = new THREE.Clock();

// custom global variables
var casteller_textures = [];
var castellers;

var INTERSECTED;
var raycaster;
var mouse;
var objects = [];
var projector;

init();
animate();

// FUNCTIONS 		
function init() {

	container = document.createElement( 'div' );
	document.body.appendChild( container );

	// CAMERA
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	camera.position.set(0,250,800);

	// SCENE
	scene = new THREE.Scene();
	scene.fog = new THREE.Fog( 0xffffff, 1000, 4000 );
	scene.add( camera );
	camera.name = "camera";

	// LIGHTS
	light = new THREE.AmbientLight( 0x222222 );
	scene.add( light );
	light.name = "light";


	//  GROUND
	var gt = THREE.ImageUtils.loadTexture( "textures/terrain/image1.jpg" );
	var gg = new THREE.PlaneBufferGeometry( 16000, 16000 );
	var gm = new THREE.MeshPhongMaterial( { color: 0xfdfdfd, map: gt } );

	var ground = new THREE.Mesh( gg, gm );
	ground.rotation.x = - Math.PI / 2;
	ground.material.map.repeat.set( 64, 64 );
	ground.material.map.wrapS = THREE.RepeatWrapping;
	ground.material.map.wrapT = THREE.RepeatWrapping;
	// note that because the ground does not cast a shadow, .castShadow is left false
	ground.receiveShadow = true;
	ground.name = "ground";

	scene.add( ground );

	// RENDERER
	renderer = new THREE.WebGLRenderer( );
	renderer.setClearColor( scene.fog.color );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
	container.appendChild( renderer.domElement );
	

	// CONTROLS
	cameraControls = new THREE.OrbitControls( camera, renderer.domElement );
	cameraControls.target.set( 0, 50, 0 );
	
	// EVENTS
	window.addEventListener( 'resize', onWindowResize, false );
	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
	document.addEventListener( 'touchstart', onDocumentTouchStart, false );

	// initialize object to perform world/screen calculations
	raycaster = new THREE.Raycaster();
	projector = new THREE.Projector();
	mouse = new THREE.Vector2();
	
	// CHARACTERS
	loadJSON(function(response) {
	  	// Parse JSON string into object
	    castellers = JSON.parse(response);
	    
	    // ANIMATED TEXTURES!
	    for (var i = 0; i < castellers.length; i++) {
			var castellerTexture = new THREE.ImageUtils.loadTexture( 'images/castellers/'+castellers[i].image);

			casteller_textures[i] = new TextureAnimator( castellerTexture, 64, 1, 64, 200 ); // texture, #horiz, #vert, #total, duration.
			var casteller_size = castellers[i].size;
			//canvas texture (casteller id)
			// create a canvas element
			var casteller_id_canvas = document.createElement('canvas');
			var casteller_id_context = casteller_id_canvas.getContext('2d');
			casteller_id_context.font = "Bold 40px Arial";
			casteller_id_context.fillStyle = "rgba(129,97,131,0.91)";
		    casteller_id_context.fillText(castellers[i].id, 0, casteller_size);
		    
			// canvas contents will be used for a texture
			var casteller_id_texture = new THREE.Texture(casteller_id_canvas) 
			casteller_id_texture.needsUpdate = true;

			var materials = []
			var castellerMaterial = new THREE.MeshBasicMaterial( { map: castellerTexture, side:THREE.DoubleSide, overdraw: true } );
		    materials.push(new THREE.MeshBasicMaterial( { color: 0x816183, overdraw: true } ));
		    materials.push(new THREE.MeshBasicMaterial( { color: 0x816183, overdraw: true } ));
		    materials.push(new THREE.MeshBasicMaterial( { color: 0x816183, overdraw: true } ));
		    materials.push(new THREE.MeshBasicMaterial( { color: 0x816183, overdraw: true } ));
			materials.push(castellerMaterial);
			materials.push(new THREE.MeshBasicMaterial( { map: casteller_id_texture, color: 0x816183, overdraw: true } ));

			var castellerGeometry = new THREE.CubeGeometry(casteller_size, casteller_size, 1, 1, 1, 1 );
			var facesMaterial = new THREE.MeshFaceMaterial(materials);
			var casteller = new THREE.Mesh(castellerGeometry, facesMaterial);
			casteller.name = castellers[i].name;
			casteller.casteller_id = castellers[i].id;
			casteller.overdraw = true;
			casteller.rotation.y = Math.PI * castellers[i].position.rotation_y;
			casteller.rotation.x = Math.PI * castellers[i].position.rotation_x;
			casteller.position.set(
				castellers[i].position.axis_x,
				castellers[i].position.axis_y,
				castellers[i].position.axis_z
				);
			scene.add(casteller);
			objects.push(casteller);
		};

 	});



	
}


function onWindowResize() {

	
	SCREEN_WIDTH = window.innerWidth;
	SCREEN_HEIGHT = window.innerHeight;

	renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );

	camera.aspect = SCREEN_WIDTH/ SCREEN_HEIGHT;
	camera.updateProjectionMatrix();

}

function animate() 
{
    requestAnimationFrame( animate );
	render();		
	update();
}

function update()
{
	var delta = clock.getDelta(); 
	for (var i = 0; i < casteller_textures.length; i++) {
		casteller_textures[i].update(1000 * delta);
	};
		
	cameraControls.update();
}

function onDocumentTouchStart( event ) {
	event.preventDefault();
	
	event.clientX = event.touches[0].clientX;
	event.clientY = event.touches[0].clientY;
	onDocumentMouseDown( event );

}

function onDocumentMouseDown( event ) {
	console.log("******************** mouse down");

	event.preventDefault();

	// update the mouse variable
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;


	var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
	projector.unprojectVector( vector, camera );
	var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

	// create an array containing all objects in the scene with which the ray intersects
	var intersects = ray.intersectObjects( objects );


	if ( intersects.length > 0 ) {

		// store reference to closest object as current intersection object
		INTERSECTED = intersects[ 0 ].object;
		var casteller_id = INTERSECTED.casteller_id;
		console.log("INTERSECTED "+INTERSECTED.casteller_id);
		var casteller;
		for (var i = 0; i < castellers.length; i++) {
			if (castellers[i].id==casteller_id){
				casteller = castellers[i];
				console.log(casteller);
			}
		}
		if($("#videoBox").is(':empty')){
			//$("#videoBox").append("<video width='320' height='240' src='videos/"+casteller.video+"' controls autoplay></video>");
			$('#videoBox').attr('title',casteller.name);
			$("#videoBox").append("<iframe width='320' height='240' src='"+casteller.youtube+"' frameborder='0' allowfullscreen></iframe>");
			$("#videoBox").append("<h2>"+casteller.name+" "+casteller.id+"</h2>");
			$("#videoBox").append("<p>"+casteller.info+"</p>");
		}
		$("#videoBox").dialog("open");
	}

}

function render() 
{

	renderer.render( scene, camera );
}

function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) 
{	
	// note: texture passed by reference, will be updated by the update function.
		
	this.tilesHorizontal = tilesHoriz;
	this.tilesVertical = tilesVert;
	// how many images does this spritesheet contain?
	//  usually equals tilesHoriz * tilesVert, but not necessarily,
	//  if there at blank tiles at the bottom of the spritesheet. 
	this.numberOfTiles = numTiles;
	texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
	texture.repeat.set( 1 / this.tilesHorizontal, 1 / this.tilesVertical );

	// how long should each image be displayed?
	this.tileDisplayDuration = tileDispDuration;

	// how long has the current image been displayed?
	this.currentDisplayTime = 0;

	// which image is currently being displayed?
	this.currentTile = 0;
		
	this.update = function( milliSec )
	{
		this.currentDisplayTime += milliSec;
		while (this.currentDisplayTime > this.tileDisplayDuration)
		{
			this.currentDisplayTime -= this.tileDisplayDuration;
			this.currentTile++;
			if (this.currentTile == this.numberOfTiles)
				this.currentTile = 0;
			var currentColumn = this.currentTile % this.tilesHorizontal;
			texture.offset.x = currentColumn / this.tilesHorizontal;
			var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
			texture.offset.y = currentRow / this.tilesVertical;
		}
	};
}	

function loadJSON(callback) {   

    var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
    xobj.open('GET', 'castellers.json', true); 
    xobj.onreadystatechange = function () {
          if (xobj.readyState == 4 && xobj.status == "200") {
            // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
            callback(xobj.responseText);
          }
    };
    xobj.send(null);  
}	

</script>

</body>
</html>
